
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>multiflex_sdp_climate_StaticFlex_DetT_Nov2021</title><meta name="generator" content="MATLAB 9.9"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-11-10"><meta name="DC.source" content="multiflex_sdp_climate_StaticFlex_DetT_Nov2021.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">DOCUMENTATION:</a></li><li><a href="#2">OPTIMAL DAM DESIGN SETUP</a></li><li><a href="#3">Climate change uncertainty stochastic dynamic program (SDP)</a></li><li><a href="#4">Setup</a></li><li><a href="#5">Parameters</a></li><li><a href="#6">SDP State and Action Definitions</a></li><li><a href="#7">Calculate climate transition matrix</a></li><li><a href="#8">T, P, Runoff monthly time series for each long-term T, P state</a></li><li><a href="#9">Use reservoir operation model to calculate yield and shortage costs</a></li><li><a href="#10">Solve SDP optimal policies using backwards recursion</a></li><li><a href="#11">Forward simulation</a></li></ul></div><h2 id="1">DOCUMENTATION:</h2><p>This is V6 of multiflex_sdp_climate_StaticFlex_DetT.m (date: 11/02/2021)</p><pre class="codeinput"><span class="comment">% DESCRIPTION:</span>
<span class="comment">% This script parallels the structure of the script sdp_climate.m. The</span>
<span class="comment">% current version of this script supports preloaded shortage costs to be</span>
<span class="comment">% loaded within the script so that the dimensions of the shortage costs data is</span>
<span class="comment">% represents multiple flexible dam sizes(i.e., possible to set</span>
<span class="comment">% runParam.calcShortage = false).</span>

<span class="comment">% The updated SDP action space allows for dam expansion to optParam.numFlex number</span>
<span class="comment">% of possible flexible expansion capacities with expanded capacities increasing</span>
<span class="comment">% at an increment of optParam.flexIncr MCM  starting from the smallest</span>
<span class="comment">% capacity, optParam.smallCap. This script allows for a reactive and</span>
<span class="comment">% proactive dam expansion process to be considered.</span>

<span class="comment">% The capacity state space in the SDP now allows for: an optimal static option,</span>
<span class="comment">% an optimal planned dam option, an optimal initial flexible dam option with</span>
<span class="comment">% and optParam.numFlex different expanded flexible dam capacities at optParam.flexIncr</span>
<span class="comment">% increments of added capacity.</span>

<span class="comment">% OPTIMAL DAM SIZE FROM THE SDP:</span>
<span class="comment">% if optParam.optFlex = 2, then the SDP forces the static dam option to</span>
<span class="comment">% be selected initially so that the value function in the SDP corresponds to the</span>
<span class="comment">% static dam.</span>

<span class="comment">% if optParam.optFlex = 1, then the SDP forces the flexible dam option to</span>
<span class="comment">% be selected initially so that the value function in the SDP corresponds to the</span>
<span class="comment">% flexible dams.</span>

<span class="comment">% if optParam.optFlex = 0, then the SDP does not force the flexible or static</span>
<span class="comment">% dam option to be selected initially (selects whatever is the best</span>
<span class="comment">% option). This is useful when selecting runParam.forwardSim = true.</span>

<span class="comment">% NOTE:</span>
<span class="comment">% As calculation of the optimized reservoir operations via DDP</span>
<span class="comment">% is computationally time intensive,it is recommended to run the script</span>
<span class="comment">% runParam.optReservoir = true only when runParam.calcShortage = false.)</span>

<span class="comment">% If using pre-saved shortage costs, shortage cost files for flexible dam</span>
<span class="comment">% will be created within the "calculate shortage cost section." Use</span>
<span class="comment">% runParam.calcShortage = false to use preloaded data contained in the</span>
<span class="comment">% folders 'post_process_nonopt_reservoir_results' and</span>
<span class="comment">% 'post_process_opt_reservoir_results.'</span>
</pre><h2 id="2">OPTIMAL DAM DESIGN SETUP</h2><pre class="codeinput"><span class="comment">% ================== SETUP FOR FINDING OPTIMAL DESIGN =====================</span>
optParam = struct;

<span class="comment">% specify whether the SDP should optimize for a flexible or static</span>
<span class="comment">% dam design. If (1), optimize design for a flexible dam. If (2),</span>
<span class="comment">% optimize the design for a static dam. If (3), optimize design for flexibly</span>
<span class="comment">% planned dam. If (0), do not force dam design decision in time period N = 1.</span>
optParam.optFlex = x(1); <span class="comment">%0;</span>

<span class="comment">% ======================== OPTIMAL DAM DESIGNS ============================</span>
<span class="comment">% capacity values range 50:5:150 in the dam costmodel</span>

<span class="comment">% STATIC DAM</span>
optParam.staticCap = x(2); <span class="comment">% static dam size [MCM]</span>

<span class="comment">% FLEXIBLE DESIGN DAM</span>
optParam.smallFlexCap = x(3); <span class="comment">% unexpanded flexible design dam size [MCM]</span>
optParam.numFlex = x(4);  <span class="comment">% number of possible expansion capacities [#]</span>
optParam.flexIncr = x(5); <span class="comment">% increment of flexible expansion capacities [MCM]</span>

<span class="comment">% flexible design dam cost parameters</span>
costParam.PercFlex = x(6); <span class="comment">% Initial upfront capital cost increase (0.075)</span>
costParam.PercFlexExp = x(7); <span class="comment">% Expansion cost of flexible dam  (0.15)</span>

<span class="comment">% FLEXIBLE PLANNING DAM</span>
optParam.smallPlanCap = x(8); <span class="comment">% unexpanded flexible planning dam size [MCM]</span>
optParam.numPlan = x(9); <span class="comment">% MCM</span>
optParam.planIncr = x(10);

<span class="comment">% flexible planning dam cost parameters</span>
costParam.PercPlan = x(11); <span class="comment">% initial upfront capital cost increase (0);</span>
costParam.PercPlanExp = x(12); <span class="comment">% expansion cost of flexibly planned dam (0.5)</span>
</pre><pre class="codeoutput error">Undefined function 'x' for input arguments of type 'double'.

Error in multiflex_sdp_climate_StaticFlex_DetT_Nov2021 (line 55)
optParam.optFlex = x(1); %0;
</pre><h2 id="3">Climate change uncertainty stochastic dynamic program (SDP)</h2><pre class="codeinput"><span class="comment">% This is the main script in the analysis: it integrates the Bayesian</span>
<span class="comment">% statitiscal model results, CLIRUN rainfall-runoff model, and water</span>
<span class="comment">% system/cost models into the forumulation of an SDP. The SDP develops</span>
<span class="comment">% optimal policies for 1) which of three infrastructure alternatives to</span>
<span class="comment">% choose in an initial planning period and 2) under what climate conditions</span>
<span class="comment">% to add capacity in a flexible planning process. Finally, it uses Monte</span>
<span class="comment">% Carlo simulation on the uncertain climate states to assess the peformance</span>
<span class="comment">% of the infrastructure policies developed by the SDP.</span>
</pre><h2 id="4">Setup</h2><pre class="codeinput"><span class="comment">% Set Project root folder and Add subfolders to path; runs either on desktop</span>
<span class="comment">% or on a cluster using SLURM queueing system</span>
<span class="keyword">if</span> ~isempty(getenv(<span class="string">'SLURM_JOB_ID'</span>))
    projpath = <span class="string">'/net/fs02/d2/sfletch/Mombasa_climate'</span>;
<span class="keyword">else</span>
    projpath = <span class="string">'/Users/sarahfletcher/Dropbox (MIT)/Fletcher_2019_Learning_Climate'</span>;
<span class="keyword">end</span>
addpath(genpath(projpath))

jobid = getenv(<span class="string">'SLURM_JOB_ID'</span>);

<span class="comment">% Get date for file name when saving results</span>
datetime=datestr(now);
datetime=strrep(datetime,<span class="string">':'</span>,<span class="string">'_'</span>); <span class="comment">%Replace colon with underscore</span>
datetime=strrep(datetime,<span class="string">'-'</span>,<span class="string">'_'</span>);<span class="comment">%Replace minus sign with underscore</span>
datetime=strrep(datetime,<span class="string">' '</span>,<span class="string">'_'</span>);<span class="comment">%Replace space with underscore</span>
</pre><h2 id="5">Parameters</h2><pre class="codeinput"><span class="comment">% Set up run parameters</span>
<span class="comment">% Two purposes: 1) different pieces can be run independently using</span>
<span class="comment">% saved results and 2) different planning scenarios (table 1) can be run</span>

<span class="comment">% ========================= GENERAL SCRIPT SETUP ==========================</span>

runParam = struct;

<span class="comment">% Number of time periods</span>
runParam.N = 5; <span class="comment">% Current SDP model requires N = 5</span>

<span class="comment">% If true, run SDP to calculate optimal policies</span>
runParam.runSDP = true; <span class="comment">%x(9)</span>

<span class="comment">% Number of years to generate in T, P, streamflow time series</span>
runParam.steplen = 20;

<span class="comment">% Set Emissions Scenario</span>
emisScenario = {<span class="string">'RCP19'</span> <span class="string">'RCP26'</span> <span class="string">'RCP34'</span> <span class="string">'RCP45'</span> <span class="string">'RCP6'</span> <span class="string">'RCP7'</span> <span class="string">'RCP85'</span>};
runParam.setPathway = emisScenario{7};

<span class="comment">% If true, simulate runoff time series from T, P time series using CLIRUN. If false, load saved.</span>
runParam.runRunoff = false;

<span class="comment">% If true, simulate T, P time series from mean T, P states using stochastic weather gen. If false, load saved.</span>
runParam.runTPts = false;

<span class="comment">% If true, change indices of saved runoff time series to correspond to T, P states (needed for parfor implementation)</span>
runParam.runoffPostProcess = false;

<span class="comment">% If true, use optimal policies from SDP to do Monte Carlo simulation to esimate performance</span>
runParam.forwardSim = x(13);  <span class="comment">%false;%</span>

<span class="comment">% If true, calculate Bellman transition matrix from BMA results. If false, load saved.</span>
runParam.calcTmat = false;

<span class="comment">% If true, apply the adaptive reservoir operations policy via SDP in the water</span>
<span class="comment">% system model. If false, use the non-adaptive reservoir operations policy</span>
<span class="comment">% via SDP</span>
runParam.optReservoir = x(14);

<span class="comment">% If true, calculate water shortage costs from runoff times series using water system model. If false, load saved.</span>
runParam.calcShortage = false;

<span class="comment">% Urban water demand scenarios (low = 150,000; high = 300,000)[m3/d](Fletcher 2019)</span>
runParam.domDemand = 186000;

<span class="comment">% If false, do not include deslination plant (planning scenarios A and B</span>
<span class="comment">% with current demand in table 1). If true, include desalination plant</span>
<span class="comment">% (planning scenario C with higher deamnd).</span>
runParam.desalOn = false;

<span class="comment">% Size of desalination plant for small and large versions [MCM/y]</span>
runParam.desalCapacity = [60 80];

<span class="comment">% If using pre-saved runoff time series, name of .mat file to load</span>
runParam.runoffLoadName = <span class="string">'runoff_by_state_02Nov2021'</span>;

<span class="comment">% If true, save results</span>
runParam.saveOn = false;

<span class="comment">% Set up climate parameters</span>
climParam = struct;

<span class="comment">%  Number of simulations to use in order to estimate absolute T and P</span>
<span class="comment">%  values based on relative difference from one time period to the next</span>
climParam.numSamp_delta2abs = 100000;

<span class="comment">% Number of T,P time series to generate using stochastic weather generator</span>
climParam.numSampTS = 100;

<span class="comment">% If true, test number of simulated climate values are outside the range of</span>
<span class="comment">% the state space in order to ensure state space validity</span>
climParam.checkBins = false;

<span class="comment">% Set up cost parameters; vary for sensitivity analysis</span>
costParam = struct;

<span class="comment">% Value of shortage penalty for domestic use [$/m3]</span>
costParam.domShortage = 0.65; <span class="comment">% Fletcher et al. (2019) utilized 5</span>

<span class="comment">% Value of shortage penalty for ag use [$/m3]</span>
costParam.agShortage = 0.28; <span class="comment">% Fletcher et al. (2019) utilized 0</span>

<span class="comment">% Use the parameter c' to scale the quadratic shortage cost formulation to</span>
<span class="comment">% reflect the average water unit cost reported by the FAO for Africa.</span>
costParam.cPrime = 6e-6; <span class="comment">%7.65e-5;%Recent:4.85e-7; %V1: 1.6e-7; %1.85e-9; % [$/m^6];</span>

<span class="comment">% Discount rate</span>
costParam.discountrate = x(15); <span class="comment">%0.03;</span>
</pre><h2 id="6">SDP State and Action Definitions</h2><pre class="codeinput">N = runParam.N;

<span class="comment">% Define state space for mean 20-year precipitation and temperature</span>
<span class="comment">% output: 66 mm/month to 97 mm/month</span>

<span class="comment">% Percent change in precip from one time period to next</span>
climParam.P_min = -.3;
climParam.P_max = .3;
climParam.P_delta = .02;
s_P = climParam.P_min : climParam.P_delta : climParam.P_max;
climParam.P0 = s_P(15);
climParam.P0_abs = 77; <span class="comment">%mm/month</span>
M_P = length(s_P);

<span class="comment">% Change in temperature from one time period to next</span>
<span class="comment">% output: 26.25, 26.75, 27.25, 27.95, 28.8 deg. C</span>

climParam.T_delta = [0.5 0.5 0.7 0.85];
climParam.T0_abs = 26.25;
M_T = N;

<span class="comment">% Absolute temperature values</span>
T_abs_max = sum(climParam.T_delta);
s_T_abs(1) = climParam.T0_abs;
<span class="keyword">for</span> i=1:N-1
    s_T_abs(i+1) = s_T_abs(i) + climParam.T_delta(i);
<span class="keyword">end</span>
M_T_abs = length(s_T_abs);
T_Temp_abs = zeros(M_T_abs,M_T_abs,N);

<span class="comment">% Absolute precip values</span>
P_abs_max = max(s_P) * N;
s_P_abs = 66:1:97;
M_P_abs = length(s_P_abs);
P_bins = [s_P_abs-climParam.P_delta/2 s_P_abs(end)+climParam.P_delta/2];
T_Precip_abs = zeros(M_P_abs,M_P_abs,N);

<span class="comment">% State space for capacity variables</span>
s_C = 1:4+optParam.numFlex+optParam.numPlan;
                            <span class="comment">% 1 - static; 2 - flex, no exp; 3- flex planned, no exp</span>
                            <span class="comment">% 4:4+optParam.numFlelx - flex, expanded to option X ,</span>
                            <span class="comment">% 4+optParam.numFlelx - flex planned, expanded</span>
                            <span class="comment">% to option X</span>

M_C = length(s_C);

storage = zeros(1, 3+optParam.numFlex + optParam.numPlan);
storage(1) = optParam.staticCap; <span class="comment">% added line</span>
storage(2) = optParam.smallCap; <span class="comment">% edited line from (1) to (2)</span>
storage(3) = optParam.planCap;
<span class="comment">% expansion from small capacity (2) to (3). Maximum dam capacity considered</span>
<span class="comment">% is 150 MCM by the World Bank for the Mwache Dam project.</span>
storage(4:3+optParam.numFlex) = min(storage(2) + (1:optParam.numFlex)*optParam.flexIncr, 150);
storage(4+optParam.numFlex:end) = min(storage(3) + (1:optParam.numPlan)*optParam.flexIncr, 150);

<span class="comment">% Actions: Choose dam option in time period 1; expand dam in future time</span>
<span class="comment">% periods</span>

a_exp = 0:3+optParam.numFlex+optParam.numPlan; <span class="comment">% 0 - do nothing; 1 - build small;</span>
                              <span class="comment">% 2 - build flex; 3:end - expand to flex option X</span>

<span class="comment">% Define infrastructure costs</span>
infra_cost = zeros(1,length(a_exp));
<span class="keyword">if</span> ~runParam.desalOn

    <span class="comment">% Planning scenarios A and B with current demand: only model dam</span>

    <span class="comment">% dam costs</span>
    infra_cost(2) = storage2damcost(storage(1),0); <span class="comment">% cost of static dam</span>
    <span class="keyword">for</span> i = 1:optParam.numFlex
        [infra_cost(3), infra_cost(i+4)] = storage2damcost(storage(2), <span class="keyword">...</span>
            storage(i+3),costParam.PercFlex, costParam.PercFlexExp); <span class="comment">% cost of flexible design exp to option X</span>
    <span class="keyword">end</span>
    <span class="keyword">for</span> i = 1:optParam.numPlan
        [infra_cost(4), infra_cost(i+3+optParam.numFlex)] = storage2damcost(storage(3), <span class="keyword">...</span>
            storage(i+2),costParam.PercPlan, costParam.PercPlanExp); <span class="comment">% cost of flexible planning exp to option X</span>
    <span class="keyword">end</span>

    <span class="comment">%for each expanded threshold, calculate (from small expansion to larger</span>
    <span class="comment">%expansion):</span>
    flexexp = zeros(1,M_C-3);
    <span class="keyword">for</span> i=1:length(flexexp)-optParam.numPlan <span class="comment">% for the flexible design dam</span>
        flexexp(i) = infra_cost(3) + infra_cost(4+i); <span class="comment">%flexexp(i) = infra_cost(4) + infra_cost(4+i); % total expanded cost for each option</span>
    <span class="keyword">end</span>
    <span class="keyword">for</span> i=length(flexexp)-optParam.numPlan+1:length(flexexp) <span class="comment">% for the flexiblity planned dam</span>
        flexexp(i) = infra_cost(4) + infra_cost(4+optParam.numFlex+i); <span class="comment">%flexexp(i) = infra_cost(4) + infra_cost(4+i); % total expanded cost for each option</span>
    <span class="keyword">end</span>
<span class="keyword">else</span>

    <span class="comment">% Planning scenario C: dam exists, make decision about new desalination plant</span>
    <span class="comment">% 6/16: Not updated</span>
    <span class="comment">% desal capital costs</span>
    [infra_cost(2),~,opex_cost] = capacity2desalcost(runParam.desalCapacity(1),0); <span class="comment">% small</span>
    infra_cost(3) = capacity2desalcost(runParam.desalCapacity(2),0); <span class="comment">% large</span>
    [infra_cost(4), infra_cost(5)] = capacity2desalcost(runParam.desalCapacity(1), runParam.desalCapacity(2));

    <span class="comment">% desal capital costs two individual plants</span>
    infra_cost(4) = infra_cost(2);
    infra_cost(5) = capacity2desalcost(runParam.desalCapacity(2) - runParam.desalCapacity(1),0);
<span class="keyword">end</span>
</pre><h2 id="7">Calculate climate transition matrix</h2><pre class="codeinput"><span class="comment">% Calculate the Bellman transition vector for the climate states using the</span>
<span class="comment">% Bayesian statistical model</span>

<span class="keyword">if</span> runParam.calcTmat
    load(<span class="string">'BMA_results_RCP85_2020-11-14.mat'</span>)
    [T_Temp, T_Precip, ~, ~, ~, ~] = bma2TransMat( NUT, NUP, s_T, s_P, N, climParam);
    T_name = strcat(<span class="string">'T_Temp_Precip_'</span>, runParam.setPathway) <span class="comment">% save a different transition matrix file for different emissions pathways</span>
    save(T_name, <span class="string">'T_Temp'</span>, <span class="string">'T_Precip'</span>)
<span class="keyword">else</span>
    load(<span class="string">'T_Temp_Precip_RCP85B'</span>, <span class="string">'T_Precip'</span>) <span class="comment">% updated from Jenny</span>
    T_Temp = deterministicTempMatrix(N);
<span class="keyword">end</span>

<span class="comment">% Prune state space -- no need to calculate policies for T and P states</span>
<span class="comment">% that are never reached when simulating future climates based on Bayesian</span>
<span class="comment">% model</span>
<span class="keyword">for</span> t = 1:N
    index_s_p_time{t} = find(~isnan(T_Precip(1,:,t)));
    index_s_t_time{t} = find(~isnan(T_Temp(1,:,t)));
<span class="keyword">end</span>
</pre><h2 id="8">T, P, Runoff monthly time series for each long-term T, P state</h2><pre class="codeinput"><span class="comment">% Use k-nn stochastic weather generator (Rajagopalan et al. 1999) to</span>
<span class="comment">% generate time series of monthly T and P based on 20-year means from state</span>
<span class="comment">% space</span>

<span class="keyword">if</span> runParam.runTPts

    T_ts = cell(M_T_abs,N);
    P_ts = cell(M_P_abs,N);

    [Tanom, Panom] = mean2TPtimeseriesMJL_2(1, runParam.steplen, climParam.numSampTS);
    <span class="keyword">for</span> t = 1:N

        <span class="keyword">for</span> i = 1:M_T_abs
            T_ts{i,t} = Tanom + s_T_abs(i)*ones(size(Tanom));
        <span class="keyword">end</span>

        <span class="keyword">for</span> i = 1:M_P_abs
            Ptmp = Panom + s_P_abs(i)*ones(size(Tanom));
            Ptmp(Ptmp&lt;0) = 0;
            P_ts{i,t} = Ptmp;
        <span class="keyword">end</span>

    <span class="keyword">end</span>

    savename_runoff = strcat(<span class="string">'runoff_by_state_'</span>, jobid,<span class="string">'_'</span>, datetime);
    save(savename_runoff, <span class="string">'T_ts'</span>, <span class="string">'P_ts'</span>)

<span class="keyword">end</span>


<span class="comment">% Use CLIRUN hydrological model to simulate runoff monthly time series for</span>
<span class="comment">% each T,P time series</span>

<span class="keyword">if</span> runParam.runRunoff

    <span class="comment">% Generate runoff timeseries - different set for each T,P combination</span>
    runoff = cell(M_T_abs, M_P_abs, N);


    <span class="comment">% Set up parallel for running on cluster with SLURM queueing system</span>
    pc = parcluster(<span class="string">'local'</span>);
    <span class="keyword">if</span> ~isempty(getenv(<span class="string">'SLURM_JOB_ID'</span>))
        parpool(pc, str2num(getenv(<span class="string">'SLURM_CPUS_ON_NODE'</span>)));
    <span class="keyword">end</span>

    <span class="keyword">for</span> t = 1

        <span class="comment">% loop over available temp states</span>
        index_s_t_thisPeriod = index_s_t_time{t};
        <span class="keyword">parfor</span> i = 1:length(index_s_t_thisPeriod)
            index_s_t = index_s_t_thisPeriod(i);

            runoff_temp = cell(M_P_abs,1);

            <span class="comment">% loop over available precip states</span>
            index_s_p_thisPeriod = index_s_p_time{t};
            <span class="keyword">for</span> index_s_p = index_s_p_thisPeriod

                <span class="comment">% Call CLIRUN streamflow simulator</span>
                runoff_temp{index_s_p} = <span class="keyword">...</span>
                    TP2runoff(T_ts{index_s_t,t}, P_ts{index_s_p,t}, runParam.steplen);

            <span class="keyword">end</span>

            runoff(i, :, t) = runoff_temp;

        <span class="keyword">end</span>
    <span class="keyword">end</span>


    savename_runoff = strcat(<span class="string">'runoff_by_state_'</span>, jobid,<span class="string">'_'</span>, datetime);
    save(savename_runoff, <span class="string">'runoff'</span>, <span class="string">'T_ts'</span>, <span class="string">'P_ts'</span>)


    <span class="keyword">if</span> runParam.runoffPostProcess
        <span class="comment">% The nature of the parfor loop above saves the runoff timeseries in</span>
        <span class="comment">% first available index; this section moves to correct cell</span>
        <span class="comment">% corresponsing to P, T state space</span>
        runoff_post = cell(M_T_abs, M_P_abs, N);
        <span class="keyword">for</span> t = 1:N

            index_s_p_thisPeriod = index_s_p_time{t};
            <span class="keyword">for</span> index_s_p = index_s_p_thisPeriod

                index_s_t_thisPeriod = index_s_t_time{t};
                <span class="keyword">for</span> i= 1:length(index_s_t_thisPeriod)

                    runoff_post{index_s_t_thisPeriod(i),index_s_p,t} = runoff{i,index_s_p,t};

                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        runoff = runoff_post;

        savename_runoff = strcat(<span class="string">'runoff_by_state_'</span>, jobid,<span class="string">'_'</span>, datetime);
        save(savename_runoff, <span class="string">'runoff'</span>, <span class="string">'T_ts'</span>, <span class="string">'P_ts'</span>)

    <span class="keyword">end</span>

<span class="keyword">else</span>

<span class="comment">% If not calculating runoff now, load previously calculated runoff</span>
load(runParam.runoffLoadName);

<span class="keyword">end</span>
</pre><h2 id="9">Use reservoir operation model to calculate yield and shortage costs</h2><pre class="codeinput"><span class="keyword">if</span> runParam.calcShortage

    unmet_ag = nan(M_T_abs, M_P_abs, length(storage), N);   <span class="comment">% Unmet demand for agriculture use</span>
    unmet_dom = nan(M_T_abs, M_P_abs, length(storage), N);  <span class="comment">% Unmet demand for domestic use</span>
    unmet_ag_squared = nan(M_T_abs, M_P_abs, length(storage), N); <span class="comment">% Squared unmet agriculuture demands</span>
    unmet_dom_squared = nan(M_T_abs, M_P_abs, length(storage), N); <span class="comment">% Squared unmet domestic demands</span>
    yield = nan(M_T_abs, M_P_abs, length(storage), N);  <span class="comment">% Yield from reservoir</span>
    desal = cell(M_T_abs, M_P_abs, length(storage));    <span class="comment">% Production of desalinated water</span>

    <span class="keyword">for</span> t = 1 <span class="comment">% Consider N = 1 assuming that the hydrological model and reservoir operations do not vary significantly between planning periods (N)</span>

        index_s_p_thisPeriod = index_s_p_time{t};

        <span class="keyword">for</span> index_s_p = 1:length(s_P_abs)

            index_s_t_thisPeriod = index_s_t_time{t};
            <span class="keyword">for</span> index_s_t= 1:length(s_T_abs)

                <span class="keyword">for</span> s = 1:length(storage) <span class="comment">% for each capacity scenario, find shortage costs from operations</span>
                    <span class="comment">% Two options depending on planning scenario from Table</span>
                    <span class="comment">% 1: In scenarios A and B, with low demand, only the</span>
                    <span class="comment">% dam is modeled, and different levels of capacity in</span>
                    <span class="comment">% the state space corresponds to different reservoir</span>
                    <span class="comment">% volumes (desalOn = false). In scenario C, a</span>
                    <span class="comment">% desalination plant is modeled to support higher</span>
                    <span class="comment">% demand &gt; MAR. In this case (desalOn = true), the</span>
                    <span class="comment">% state space corresponds to different desalination</span>
                    <span class="comment">% capacity volumes, assuming the large volume of</span>
                    <span class="comment">% reservoir storage.</span>

                    <span class="keyword">if</span> ~runParam.desalOn
                        <span class="comment">% vary storage, no desal</span>
                        [yield_mdl, K, dmd, unmet_dom_mdl, unmet_ag_mdl, desalsupply, desalfill]  = <span class="keyword">...</span>
                            runoff2yield(runoff{index_s_t,index_s_p,t}, T_ts{index_s_t,t}, P_ts{index_s_p,t}, storage(s), 0, runParam, climParam, costParam);
                    <span class="keyword">else</span>
                        <span class="comment">% large storage, vary desal</span>
                        [yield_mdl, K, dmd, unmet_dom_mdl, unmet_ag_mdl, desalsupply, desalfill]  = <span class="keyword">...</span>
                            runoff2yield(runoff{index_s_t,index_s_p,t}, T_ts{index_s_t,t}, P_ts{index_s_p,t}, storage(2), runParam.desalCapacity(s), runParam, climParam, costParam);
                    <span class="keyword">end</span>

                    <span class="comment">% OMITTED: 'Calculate ummet demand, allowing for 10% of domestic demand</span>
                    <span class="comment">% to be unpenalized per 90% reliability goal(unmet_dom_90)'</span>

                    unmet_ag(index_s_t, index_s_p, s, t) = mean(sum(unmet_ag_mdl,2));
                    unmet_dom(index_s_t, index_s_p, s, t) = mean(sum(unmet_dom_mdl,2));
                    unmet_ag_squared(index_s_t, index_s_p, s, t) = mean(sum(unmet_ag_mdl.^2,2));
                    unmet_dom_squared(index_s_t, index_s_p, s, t) = mean(sum(unmet_dom_mdl.^2,2));
                    yield(index_s_t, index_s_p, s, t) = mean(sum(yield_mdl,2));
                    <span class="keyword">if</span> runParam.desalOn
                        desal{index_s_t, index_s_p, s} = desalsupply + desalfill;
                    <span class="keyword">end</span>

                <span class="keyword">end</span>

                stateMsg = strcat(<span class="string">'s_p ='</span>, num2str(index_s_p), <span class="string">'/ '</span>, num2str(length(s_P_abs)), <span class="string">', s_t='</span>, num2str(index_s_t), <span class="string">'/  '</span>,  num2str(length(s_T_abs)));
                disp(stateMsg)

            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% Calculate shortage costs incurred for unmet demand, using</span>
    <span class="comment">% differentiated costs for agriculture and domestic shortages and</span>
    <span class="comment">% quadratic formulation</span>
    shortageCost =  (unmet_ag_squared * costParam.agShortage + unmet_dom_squared * costParam.domShortage) * 1E6;

    <span class="comment">% In planning scenario C with the desalination place, also calculate</span>
    <span class="comment">% discounted cost of oeprating the desalination plant</span>
    <span class="keyword">if</span> runParam.desalOn

        desal_opex = nan(M_T_abs, M_P_abs, length(storage), N);
        <span class="keyword">for</span> t = 1:N
            discountfactor =  repmat((1+costParam.discountrate) .^ ((t-1)*runParam.steplen+1:1/12:t*runParam.steplen+11/12), 100, 1);
            desal_opex(:,:,:,t) = cell2mat(cellfun(@(x) mean(sum(opex_cost * x ./ discountfactor, 2)), desal, <span class="string">'UniformOutput'</span>, false));
        <span class="keyword">end</span>
        <span class="keyword">else</span>
            desal_opex = [];
    <span class="keyword">end</span>

    <span class="keyword">if</span> runParam.saveOn
        savename_shortageCost = strcat(<span class="string">'shortage_costs'</span>, jobid,<span class="string">'_'</span>, datetime);
        save(savename_shortageCost, <span class="string">'shortageCost'</span>, <span class="string">'yield'</span>, <span class="string">'unmet_ag'</span>, <span class="string">'unmet_dom'</span>, <span class="string">'unmet_ag_squared'</span>, <span class="string">'unmet_dom_squared'</span>,<span class="string">'desal_opex'</span>)
    <span class="keyword">end</span>
<span class="keyword">else</span> <span class="comment">% use the pre-calculated shortage cost files to fast-track calculations</span>

    <span class="comment">% Preallocate final shortage cost matrix</span>
    shortageCost = NaN(M_T_abs, M_P_abs, length(storage), N);
    <span class="keyword">if</span> runParam.optReservoir <span class="comment">% shortage costs from adaptive reservoir operations via SDP</span>
        <span class="keyword">for</span> i=1:length(storage)
            s_state = string(storage(i));
            s_state_filename = strcat(<span class="string">'sdp_adaptive_shortage_cost_s'</span>,s_state,<span class="string">'.mat'</span>);
            shortageCostDir = load(s_state_filename,<span class="string">'shortageCost'</span>);
            shortageCost_s_state = shortageCostDir.shortageCost(:,18:49);
            shortageCost(:,:,i,1) = shortageCost_s_state;
        <span class="keyword">end</span>
    <span class="keyword">else</span> <span class="comment">% shortage costs from non-adaptive reservoir operations via SDP</span>
        <span class="keyword">for</span> i=1:length(storage)
            s_state = string(storage(i));
            s_state_filename = strcat(<span class="string">'sdp_nonadaptive_shortage_cost_s'</span>,s_state,<span class="string">'.mat'</span>);
            shortageCostDir = load(s_state_filename,<span class="string">'shortageCost'</span>);
            shortageCost_s_state = shortageCostDir.shortageCost(:,18:49);
            shortageCost(:,:,i,1) = shortageCost_s_state;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2 id="10">Solve SDP optimal policies using backwards recursion</h2><pre class="codeinput"><span class="keyword">if</span> runParam.runSDP

<span class="comment">% multiply by c' parameter for economic cost model</span>
shortageCost = shortageCost.*costParam.cPrime;

<span class="comment">% Initialize best value and best action matrices</span>
<span class="comment">% Temperature states x precipitaiton states x capacity states, time</span>
V = NaN(M_T_abs, M_P_abs, M_C, N+1);
X = NaN(M_T_abs, M_P_abs, M_C, N);

<span class="comment">% Terminal period</span>
V(:,:,:,N+1) = zeros(M_T_abs, M_P_abs, M_C, 1);

<span class="comment">% Loop over all time periods</span>
<span class="keyword">for</span> t = linspace(N,1,N)

    <span class="comment">% Calculate nextV</span>
    nextV = V(:,:,:,t+1);

    <span class="comment">% Loop over all states</span>

    <span class="comment">% Loop over temperature state</span>
    index_s_t_thisPeriod = index_s_t_time{t};
    <span class="keyword">for</span> index_s_t = index_s_t_thisPeriod
        st = s_T_abs(index_s_t);

        <span class="comment">% Loop over precipitation state</span>
        index_s_p_thisPeriod = index_s_p_time{t};
        <span class="keyword">for</span> index_s_p = index_s_p_thisPeriod
            sp = s_P_abs(index_s_p);

            <span class="comment">% Loop over capacity expansion state</span>
            <span class="keyword">for</span> index_s_c = 1:M_C
                sc = s_C(index_s_c);

                bestV = Inf;  <span class="comment">% Best value</span>
                bestX = 0;  <span class="comment">% Best action</span>

                <span class="comment">% Update available actions based on time and whether expansion available</span>

                <span class="comment">% In first period decide what dam to build</span>
                <span class="keyword">if</span> t == 1
                    <span class="keyword">if</span> optParam.optFlex == 1 <span class="comment">% flexible dam design</span>
                        a_exp_thisPeriod = 2; <span class="comment">% force building of flexible dam design at N = 1</span>
                    <span class="keyword">elseif</span> optParam.optFlex == 2 <span class="comment">% static dam</span>
                        a_exp_thisPeriod = 1; <span class="comment">% force building of static dam at N = 1</span>
                    <span class="keyword">elseif</span> optParam.optFlex == 3 <span class="comment">% flexibly planned dam</span>
                        a_exp_thisPeriod = 1; <span class="comment">% force building flexibly planned dam at N = 1</span>
                    <span class="keyword">elseif</span> optParam.optFlex == 0 <span class="comment">% flexible design, planning, or static (whatever is best option)</span>
                        a_exp_thisPeriod = 1:3; <span class="comment">% build a static or flex dam</span>
                    <span class="keyword">end</span>
                <span class="keyword">else</span>
                    <span class="comment">% In later periods decide whether to expand or not if available</span>
                    <span class="keyword">switch</span> sc
                        <span class="keyword">case</span> s_C(1) <span class="comment">% static</span>
                            a_exp_thisPeriod = [0];
                        <span class="keyword">case</span> s_C(2) <span class="comment">% Flex design, not expanded</span>
                            a_exp_thisPeriod = [0 a_exp(5:5+optParam.numFlex)]; <span class="comment">% not expand or expand to options X</span>
                        <span class="keyword">case</span> s_C(3) <span class="comment">% Flex planning, not expanded</span>
                            a_exp_thisPeriod = [0 a_exp(6+optParam.numFlex:end)]; <span class="comment">% not expand or expand to option X</span>
                        <span class="keyword">otherwise</span> <span class="comment">% Flex design or planning, any expanded option (can only expand once)</span>
                            a_exp_thisPeriod = [0];
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
                num_a_exp = length(a_exp_thisPeriod);

                <span class="comment">% Loop over expansion action</span>
                <span class="keyword">for</span> index_a = 1:num_a_exp
                    a = a_exp_thisPeriod(index_a);

                    stateMsg = strcat(<span class="string">'t='</span>, num2str(t), <span class="string">', st='</span>, num2str(st), <span class="string">', sp='</span>, num2str(sp), <span class="string">', sc='</span>, num2str(sc), <span class="string">', a='</span>, num2str(a));
                    disp(stateMsg)

                    <span class="comment">% Calculate costs</span>

                    <span class="comment">% Select which capacity is currently available</span>
                    <span class="keyword">if</span> sc == 1
                        short_ind = 1;  <span class="comment">% static capacity</span>
                    <span class="keyword">elseif</span> sc == 2
                        short_ind = 2; <span class="comment">% flex design capacity</span>
                    <span class="keyword">elseif</span> sc == 3
                        short_ind = 3; <span class="comment">% flex planning capacity</span>
                    <span class="keyword">else</span>
                        short_ind = sc; <span class="comment">% intermediate capacity X</span>
                    <span class="keyword">end</span>

                    <span class="comment">% In first time period, assume have dam built</span>
                    <span class="keyword">if</span> t == 1
                        <span class="keyword">if</span> a == 2
                            short_ind = 2; <span class="comment">% unexpanded flex design capacity</span>
                        <span class="keyword">elseif</span> a == 1
                            short_ind = 1; <span class="comment">% static capacity</span>
                        <span class="keyword">elseif</span> a == 3
                            short_ind = 3; <span class="comment">% unexpanded flex planning capacity</span>
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>

                    <span class="comment">% Assume new expansion capacity comes online this period</span>
                    <span class="keyword">if</span> (a ~= 0) &amp;&amp; (a ~=1) &amp;&amp; (a ~=2) &amp;&amp; (a ~=3)
                        short_ind = a; <span class="comment">% expanded capacity index</span>
                    <span class="keyword">end</span>

                    sCost = shortageCost(index_s_t, index_s_p, short_ind, 1);
                    <span class="keyword">if</span> t == 1
                        sCost = 0;  <span class="comment">% This is upfront building period</span>
                    <span class="keyword">end</span>

                    ind_dam = find(a == a_exp);
                    dCost = infra_cost(ind_dam);
                    cost = (sCost + dCost) / (1+costParam.discountrate)^((t-1)*runParam.steplen+1);
                    <span class="keyword">if</span> runParam.desalOn
                        opex = desal_opex(index_s_t, index_s_p, short_ind, t);
                    <span class="keyword">else</span>
                        opex = 0;
                    <span class="keyword">end</span>
                    cost = cost + opex;


                    <span class="comment">% Calculate transition matrix</span>

                    <span class="comment">% Capacity transmat vector</span>
                    T_cap = zeros(1,M_C);
                    <span class="keyword">if</span> t == 1
                        <span class="comment">% In first time period, get whatever dam you picked</span>
                        T_cap(a) = 1;
                    <span class="keyword">else</span>
                        <span class="comment">% Otherwise, either stay in current or move to expanded</span>
                        <span class="keyword">switch</span> a
                            <span class="keyword">case</span> 0
                                T_cap(sc) = 1;
                            <span class="keyword">case</span> num2cell(4:a_exp(end)) <span class="comment">% different expansion cases</span>
                                T_cap(a) = 1;
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>

                    <span class="comment">% Temperature transmat vector</span>
                    T_Temp_row = T_Temp(:,index_s_t, t)';
                    <span class="keyword">if</span> sum(isnan(T_Temp_row)) &gt; 0
                        error(<span class="string">'Nan in T_Temp_row'</span>)
                    <span class="keyword">end</span>

                    <span class="comment">% Precipitation transmat vector</span>
                    T_Precip_row = T_Precip(:,index_s_p, t)';
                    <span class="keyword">if</span> sum(isnan(T_Precip_row)) &gt; 0
                        error(<span class="string">'Nan in T_Precip_row'</span>)
                    <span class="keyword">end</span>

                    <span class="comment">% Calculate full transition matrix</span>
                    <span class="comment">% Assumes state variables are uncorrelated</span>
                    <span class="comment">% T gives probability of next state given current state and actions</span>

                    TRows = cell(3,1);
                    TRows{1} = T_Temp_row;
                    TRows{2} = T_Precip_row;
                    TRows{3} = T_cap;
                    [ T ] = transrow2mat( TRows );

                     <span class="comment">% Calculate expected future cost or percentile cost</span>
                    indexNonZeroT = find(T &gt; 0);
                    expV = sum(T(indexNonZeroT) .*nextV(indexNonZeroT));
                    <span class="keyword">for</span> i = 2:4
                        expV = sum(expV);
                    <span class="keyword">end</span>

                   <span class="comment">% Check if best decision</span>
                    checkV = cost + expV;
                    <span class="keyword">if</span> checkV &lt; bestV
                        bestV = checkV;
                        bestX = a;
                    <span class="keyword">end</span>

                <span class="keyword">end</span>

            <span class="comment">% Check that bestV is not Inf</span>
            <span class="keyword">if</span> bestV == Inf
                error(<span class="string">'BestV is Inf, did not pick an action'</span>)
            <span class="keyword">end</span>

            <span class="comment">% Save best value and action for current state</span>
            V(index_s_t, index_s_p,index_s_c, t) = bestV;
            X(index_s_t, index_s_p,index_s_c, t) = bestX;

            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">if</span> runParam.saveOn

    savename_results = strcat(<span class="string">'results'</span>, jobid,<span class="string">'_'</span>, datetime);
    save(savename_results)

<span class="keyword">end</span>


<span class="keyword">end</span>
</pre><h2 id="11">Forward simulation</h2><pre class="codeinput"><span class="comment">% Use optimal expansion policy derived from SDP to simulate performance of</span>
<span class="comment">% flexible alternative and compare to small and large alternatives</span>

<span class="comment">% 2 runs: static, flex</span>

<span class="keyword">if</span> runParam.forwardSim

R = 10000; <span class="comment">% Number of forward Monte Carlo simulations</span>
N = runParam.N; <span class="comment">% Number of time periods</span>
S = 4; <span class="comment">% Number of run options (static, flex design, flex plan, policy)</span>

T_state = zeros(R,N);
P_state = zeros(R,N);
C_state = zeros(R,N,S);
action = zeros(R,N,S);
damCostTime = zeros(R,N,S);
shortageCostTime = zeros(R,N,S);
opexCostTime = zeros(R,N,S);
totalCostTime = zeros(R,N,S);

load(<span class="string">'BMA_results_RCP85_2020-11-14.mat'</span>, <span class="string">'MUP'</span>) <span class="comment">% previously: 'BMA_results_deltap05T_p2P07-Feb-2018 20:18:49.mat'</span>
indT0 = find(s_T_abs == climParam.T0_abs);
indP0 = find(s_P_abs == climParam.P0_abs);
P0samp = MUP(:,1,indP0);
P0samp = exp(P0samp)* climParam.P0_abs;
indsamp = randi(1000,R,1);
P0samp = P0samp(indsamp);
T0samp = round2x(s_T_abs(1), s_T_abs);
P0samp = round2x(P0samp, s_P_abs);

T_state(:,1) = T0samp;
P_state(:,1) = P0samp;
C_state(:,1,1) = 2; <span class="comment">% Always flex design</span>
C_state(:,1,2) = 1; <span class="comment">% Always static</span>
C_state(:,1,3) = 3; <span class="comment">% Always flex planned</span>
C_state(:,1,4) = 2; <span class="comment">% Choose based on policy (?)</span>

<span class="keyword">for</span> i = 1:R
    <span class="keyword">for</span> t = 1:N

        <span class="comment">% Choose best action given current state</span>
            index_t = find(T_state(i,t) == s_T_abs);
            index_p = find(P_state(i,t) == s_P_abs);


        <span class="comment">% Temperature transmat vector</span>
            T_Temp_row = T_Temp(:,index_t, t)';
            <span class="keyword">if</span> sum(isnan(T_Temp_row)) &gt; 0
                error(<span class="string">'Nan in T_Temp_row'</span>)
            <span class="keyword">end</span>

            <span class="comment">% Precipitation transmat vector</span>
            T_Precip_row = T_Precip(:,index_p, t)';
            <span class="keyword">if</span> sum(isnan(T_Precip_row)) &gt; 0
                error(<span class="string">'Nan in T_Precip_row'</span>)
            <span class="keyword">end</span>

        <span class="keyword">for</span> k = 1:4

            index_c = find(C_state(i,t,k) == s_C); <span class="comment">% (?)</span>
            <span class="comment">% In flex case follow exp policy, otherwise restrict to large or</span>
            <span class="comment">% small and then no exp</span>
            <span class="keyword">if</span> t==1
                <span class="keyword">switch</span> k
                    <span class="keyword">case</span> 1
                        action(i,t,k) = 2; <span class="comment">% flex design</span>
                    <span class="keyword">case</span> 2
                        action(i,t,k) = 1; <span class="comment">% static</span>
                    <span class="keyword">case</span> 3
                        action(i,t,k) = 3; <span class="comment">% flex planning</span>
                    <span class="keyword">case</span> 4
                        action(i,t,k) =  X(index_t, index_p, index_c, t); <span class="comment">% pick best option</span>
                <span class="keyword">end</span>
            <span class="keyword">else</span>
                <span class="keyword">switch</span> k
                    <span class="keyword">case</span> 1
                        action(i,t,k) = X(index_t, index_p, index_c, t); <span class="comment">% flex design</span>
                    <span class="keyword">case</span> 2
                        action(i,t,k) = 0; <span class="comment">% static</span>
                    <span class="keyword">case</span> 3
                        action(i,t,k) =  X(index_t, index_p, index_c, t); <span class="comment">%flex planning</span>
                    <span class="keyword">case</span> 4
                        action(i,t,k) =  X(index_t, index_p, index_c, t); <span class="comment">% pick best option</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="comment">% Save costs of that action</span>

            <span class="comment">% Get current capacity and action</span>
            sc = C_state(i,t,k); <span class="comment">%for the first time period, either 1,2, or 3</span>
            a = action(i,t,k);

            <span class="comment">% Select which capacity is currently available</span>
            <span class="keyword">if</span> sc == 1
                short_ind = 1;  <span class="comment">% static capacity</span>
            <span class="keyword">elseif</span> sc == 2
                short_ind = 2; <span class="comment">% flex design capacity</span>
            <span class="keyword">elseif</span> sc == 3
                short_ind = 3; <span class="comment">% flex planning capacity</span>
            <span class="keyword">else</span>
                short_ind = sc; <span class="comment">% intermediate expanded capacity</span>
            <span class="keyword">end</span>

            <span class="comment">% In first time period, assume have dam built</span>
            <span class="keyword">if</span> t == 1
                <span class="keyword">if</span> a == 2
                    short_ind = 2; <span class="comment">% flex design capacity</span>
                <span class="keyword">elseif</span> a == 1
                    short_ind = 1;    <span class="comment">% static capacity</span>
                <span class="keyword">else</span>
                    short_ind = 3; <span class="comment">% flex planning capacity</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="comment">% Assume new expansion capacity comes online this period</span>
            <span class="keyword">if</span> (a ~= 0) &amp;&amp; (a ~=1) &amp;&amp; (a ~=2) &amp;&amp; (a~=3)
                short_ind = a; <span class="comment">% expanded capacity index</span>
            <span class="keyword">end</span>

            <span class="comment">% Get shortage and dam costs</span>
            shortageCostTime(i,t,k) = shortageCost(index_t, index_p, short_ind, 1)  / (1+costParam.discountrate)^((t-1)*runParam.steplen+1);
            <span class="keyword">if</span> t == 1
                shortageCostTime(i,t,k) = 0;  <span class="comment">% This is upfront building period</span>
            <span class="keyword">end</span>
            ind_dam = find(a == a_exp);
            damCostTime(i,t,k) = infra_cost(ind_dam)  / (1+costParam.discountrate)^((t-1)*runParam.steplen+1);
            <span class="keyword">if</span> runParam.desalOn
                opexCostTime(i,t,k) = desal_opex(index_t, index_p, short_ind, t);
            <span class="keyword">end</span>
            totalCostTime(i,t,k) = (shortageCostTime(i,t,k) + damCostTime(i,t,k));
            totalCostTime(i,t,k) = totalCostTime(i,t,k) + opexCostTime(i,t,k);

            <span class="comment">% Simulate transition to next state</span>
            <span class="comment">% Capacity transmat vector</span>
            T_cap = zeros(1,M_C);
            <span class="keyword">if</span> t == 1
                <span class="comment">% In first time period, get whatever dam you picked</span>
                T_cap(a) = 1;
            <span class="keyword">else</span>
                <span class="comment">% Otherwise, either stay in current or move to expanded</span>
                <span class="keyword">switch</span> a <span class="comment">%(?)</span>
                    <span class="keyword">case</span> 0
                        T_cap(sc) = 1;
                    <span class="keyword">case</span> num2cell(4:a_exp(end)) <span class="comment">% different expansion cases</span>
                        T_cap(a) = 1;
                <span class="keyword">end</span>
            <span class="keyword">end</span>


            <span class="comment">% Combine trans vectors into matrix</span>
            TRows = cell(3,1);
            TRows{1} = T_Temp_row;
            TRows{2} = T_Precip_row;
            TRows{3} = T_cap;
            [ T_current ] = transrow2mat( TRows );

            <span class="comment">% Simulate next state</span>
            <span class="keyword">if</span> t &lt; N
                T_current_1D = reshape(T_current,[1 numel(T_current)]);
                T_current_1D_cumsum = cumsum(T_current_1D);
                p = rand();
                index = find(p &lt; T_current_1D_cumsum,1);
                [ind_s1, ind_s2, ind_s3] = ind2sub(size(T_current),index);
                    <span class="comment">% Test sample</span>
                    margin = 1e-10;
                    <span class="keyword">if</span> (T_current(ind_s1, ind_s2, ind_s3) &lt; margin)
                        error(<span class="string">'Invalid sample from T_current'</span>)
                    <span class="keyword">end</span>

                <span class="keyword">if</span> k == 1
                    T_state(i,t+1,k) = s_T_abs(ind_s1);
                    P_state(i,t+1,k) = s_P_abs(ind_s2);
                <span class="keyword">end</span>
                C_state(i,t+1,k) = s_C(ind_s3);

            <span class="keyword">end</span>



        <span class="keyword">end</span>

    <span class="keyword">end</span>
<span class="keyword">end</span>


<span class="keyword">if</span> runParam.saveOn

    savename_results = strcat(<span class="string">'results'</span>, jobid,<span class="string">'_'</span>, datetime);
    save(savename_results)

<span class="keyword">end</span>


<span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% DOCUMENTATION:
% This is V6 of multiflex_sdp_climate_StaticFlex_DetT.m (date: 11/02/2021)

% DESCRIPTION:
% This script parallels the structure of the script sdp_climate.m. The
% current version of this script supports preloaded shortage costs to be 
% loaded within the script so that the dimensions of the shortage costs data is
% represents multiple flexible dam sizes(i.e., possible to set
% runParam.calcShortage = false).

% The updated SDP action space allows for dam expansion to optParam.numFlex number
% of possible flexible expansion capacities with expanded capacities increasing
% at an increment of optParam.flexIncr MCM  starting from the smallest
% capacity, optParam.smallCap. This script allows for a reactive and
% proactive dam expansion process to be considered.

% The capacity state space in the SDP now allows for: an optimal static option,
% an optimal planned dam option, an optimal initial flexible dam option with
% and optParam.numFlex different expanded flexible dam capacities at optParam.flexIncr
% increments of added capacity.

% OPTIMAL DAM SIZE FROM THE SDP: 
% if optParam.optFlex = 2, then the SDP forces the static dam option to
% be selected initially so that the value function in the SDP corresponds to the
% static dam.

% if optParam.optFlex = 1, then the SDP forces the flexible dam option to
% be selected initially so that the value function in the SDP corresponds to the
% flexible dams.

% if optParam.optFlex = 0, then the SDP does not force the flexible or static
% dam option to be selected initially (selects whatever is the best
% option). This is useful when selecting runParam.forwardSim = true.

% NOTE: 
% As calculation of the optimized reservoir operations via DDP 
% is computationally time intensive,it is recommended to run the script
% runParam.optReservoir = true only when runParam.calcShortage = false.)

% If using pre-saved shortage costs, shortage cost files for flexible dam
% will be created within the "calculate shortage cost section." Use
% runParam.calcShortage = false to use preloaded data contained in the
% folders 'post_process_nonopt_reservoir_results' and
% 'post_process_opt_reservoir_results.'

%% OPTIMAL DAM DESIGN SETUP 

% ================== SETUP FOR FINDING OPTIMAL DESIGN =====================
optParam = struct;

% specify whether the SDP should optimize for a flexible or static
% dam design. If (1), optimize design for a flexible dam. If (2),
% optimize the design for a static dam. If (3), optimize design for flexibly 
% planned dam. If (0), do not force dam design decision in time period N = 1.
optParam.optFlex = x(1); %0;

% ======================== OPTIMAL DAM DESIGNS ============================
% capacity values range 50:5:150 in the dam costmodel

% STATIC DAM
optParam.staticCap = x(2); % static dam size [MCM]

% FLEXIBLE DESIGN DAM
optParam.smallFlexCap = x(3); % unexpanded flexible design dam size [MCM]
optParam.numFlex = x(4);  % number of possible expansion capacities [#]
optParam.flexIncr = x(5); % increment of flexible expansion capacities [MCM]

% flexible design dam cost parameters
costParam.PercFlex = x(6); % Initial upfront capital cost increase (0.075)
costParam.PercFlexExp = x(7); % Expansion cost of flexible dam  (0.15)

% FLEXIBLE PLANNING DAM
optParam.smallPlanCap = x(8); % unexpanded flexible planning dam size [MCM]
optParam.numPlan = x(9); % MCM
optParam.planIncr = x(10);

% flexible planning dam cost parameters
costParam.PercPlan = x(11); % initial upfront capital cost increase (0);
costParam.PercPlanExp = x(12); % expansion cost of flexibly planned dam (0.5)


%% Climate change uncertainty stochastic dynamic program (SDP)

% This is the main script in the analysis: it integrates the Bayesian
% statitiscal model results, CLIRUN rainfall-runoff model, and water
% system/cost models into the forumulation of an SDP. The SDP develops
% optimal policies for 1) which of three infrastructure alternatives to
% choose in an initial planning period and 2) under what climate conditions
% to add capacity in a flexible planning process. Finally, it uses Monte
% Carlo simulation on the uncertain climate states to assess the peformance
% of the infrastructure policies developed by the SDP.


%% Setup 

% Set Project root folder and Add subfolders to path; runs either on desktop 
% or on a cluster using SLURM queueing system 
if ~isempty(getenv('SLURM_JOB_ID'))
    projpath = '/net/fs02/d2/sfletch/Mombasa_climate';
else
    projpath = '/Users/sarahfletcher/Dropbox (MIT)/Fletcher_2019_Learning_Climate';
end
addpath(genpath(projpath))

jobid = getenv('SLURM_JOB_ID');

% Get date for file name when saving results 
datetime=datestr(now);
datetime=strrep(datetime,':','_'); %Replace colon with underscore
datetime=strrep(datetime,'-','_');%Replace minus sign with underscore
datetime=strrep(datetime,' ','_');%Replace space with underscore

%% Parameters

% Set up run parameters
% Two purposes: 1) different pieces can be run independently using
% saved results and 2) different planning scenarios (table 1) can be run

% ========================= GENERAL SCRIPT SETUP ==========================

runParam = struct;

% Number of time periods
runParam.N = 5; % Current SDP model requires N = 5 

% If true, run SDP to calculate optimal policies
runParam.runSDP = true; %x(9)

% Number of years to generate in T, P, streamflow time series
runParam.steplen = 20; 

% Set Emissions Scenario
emisScenario = {'RCP19' 'RCP26' 'RCP34' 'RCP45' 'RCP6' 'RCP7' 'RCP85'};
runParam.setPathway = emisScenario{7};

% If true, simulate runoff time series from T, P time series using CLIRUN. If false, load saved.
runParam.runRunoff = false; 

% If true, simulate T, P time series from mean T, P states using stochastic weather gen. If false, load saved.
runParam.runTPts = false; 

% If true, change indices of saved runoff time series to correspond to T, P states (needed for parfor implementation)
runParam.runoffPostProcess = false; 

% If true, use optimal policies from SDP to do Monte Carlo simulation to esimate performance
runParam.forwardSim = x(13);  %false;%

% If true, calculate Bellman transition matrix from BMA results. If false, load saved.
runParam.calcTmat = false; 

% If true, apply the adaptive reservoir operations policy via SDP in the water
% system model. If false, use the non-adaptive reservoir operations policy 
% via SDP
runParam.optReservoir = x(14);

% If true, calculate water shortage costs from runoff times series using water system model. If false, load saved.
runParam.calcShortage = false; 

% Urban water demand scenarios (low = 150,000; high = 300,000)[m3/d](Fletcher 2019)
runParam.domDemand = 186000; 

% If false, do not include deslination plant (planning scenarios A and B
% with current demand in table 1). If true, include desalination plant
% (planning scenario C with higher deamnd).
runParam.desalOn = false; 

% Size of desalination plant for small and large versions [MCM/y]
runParam.desalCapacity = [60 80];

% If using pre-saved runoff time series, name of .mat file to load
runParam.runoffLoadName = 'runoff_by_state_02Nov2021';

% If true, save results
runParam.saveOn = false;

% Set up climate parameters
climParam = struct;

%  Number of simulations to use in order to estimate absolute T and P
%  values based on relative difference from one time period to the next
climParam.numSamp_delta2abs = 100000;

% Number of T,P time series to generate using stochastic weather generator
climParam.numSampTS = 100;

% If true, test number of simulated climate values are outside the range of
% the state space in order to ensure state space validity
climParam.checkBins = false;

% Set up cost parameters; vary for sensitivity analysis
costParam = struct;

% Value of shortage penalty for domestic use [$/m3]
costParam.domShortage = 0.65; % Fletcher et al. (2019) utilized 5

% Value of shortage penalty for ag use [$/m3]
costParam.agShortage = 0.28; % Fletcher et al. (2019) utilized 0

% Use the parameter c' to scale the quadratic shortage cost formulation to
% reflect the average water unit cost reported by the FAO for Africa.
costParam.cPrime = 6e-6; %7.65e-5;%Recent:4.85e-7; %V1: 1.6e-7; %1.85e-9; % [$/m^6];

% Discount rate
costParam.discountrate = x(15); %0.03;

%% SDP State and Action Definitions 

N = runParam.N;

% Define state space for mean 20-year precipitation and temperature
% output: 66 mm/month to 97 mm/month

% Percent change in precip from one time period to next
climParam.P_min = -.3;
climParam.P_max = .3;
climParam.P_delta = .02; 
s_P = climParam.P_min : climParam.P_delta : climParam.P_max;
climParam.P0 = s_P(15);
climParam.P0_abs = 77; %mm/month
M_P = length(s_P);

% Change in temperature from one time period to next
% output: 26.25, 26.75, 27.25, 27.95, 28.8 deg. C

climParam.T_delta = [0.5 0.5 0.7 0.85];
climParam.T0_abs = 26.25;
M_T = N;

% Absolute temperature values
T_abs_max = sum(climParam.T_delta);
s_T_abs(1) = climParam.T0_abs;
for i=1:N-1
    s_T_abs(i+1) = s_T_abs(i) + climParam.T_delta(i);
end
M_T_abs = length(s_T_abs);
T_Temp_abs = zeros(M_T_abs,M_T_abs,N);

% Absolute precip values
P_abs_max = max(s_P) * N;
s_P_abs = 66:1:97;
M_P_abs = length(s_P_abs);
P_bins = [s_P_abs-climParam.P_delta/2 s_P_abs(end)+climParam.P_delta/2];
T_Precip_abs = zeros(M_P_abs,M_P_abs,N);

% State space for capacity variables
s_C = 1:4+optParam.numFlex+optParam.numPlan; 
                            % 1 - static; 2 - flex, no exp; 3- flex planned, no exp
                            % 4:4+optParam.numFlelx - flex, expanded to option X , 
                            % 4+optParam.numFlelx - flex planned, expanded
                            % to option X
                            
M_C = length(s_C);

storage = zeros(1, 3+optParam.numFlex + optParam.numPlan); 
storage(1) = optParam.staticCap; % added line
storage(2) = optParam.smallCap; % edited line from (1) to (2)
storage(3) = optParam.planCap; 
% expansion from small capacity (2) to (3). Maximum dam capacity considered
% is 150 MCM by the World Bank for the Mwache Dam project.
storage(4:3+optParam.numFlex) = min(storage(2) + (1:optParam.numFlex)*optParam.flexIncr, 150);
storage(4+optParam.numFlex:end) = min(storage(3) + (1:optParam.numPlan)*optParam.flexIncr, 150);

% Actions: Choose dam option in time period 1; expand dam in future time
% periods

a_exp = 0:3+optParam.numFlex+optParam.numPlan; % 0 - do nothing; 1 - build small;  
                              % 2 - build flex; 3:end - expand to flex option X
 
% Define infrastructure costs            
infra_cost = zeros(1,length(a_exp));
if ~runParam.desalOn
    
    % Planning scenarios A and B with current demand: only model dam
    
    % dam costs
    infra_cost(2) = storage2damcost(storage(1),0); % cost of static dam
    for i = 1:optParam.numFlex
        [infra_cost(3), infra_cost(i+4)] = storage2damcost(storage(2), ...
            storage(i+3),costParam.PercFlex, costParam.PercFlexExp); % cost of flexible design exp to option X
    end
    for i = 1:optParam.numPlan
        [infra_cost(4), infra_cost(i+3+optParam.numFlex)] = storage2damcost(storage(3), ...
            storage(i+2),costParam.PercPlan, costParam.PercPlanExp); % cost of flexible planning exp to option X
    end
        
    %for each expanded threshold, calculate (from small expansion to larger
    %expansion):
    flexexp = zeros(1,M_C-3);
    for i=1:length(flexexp)-optParam.numPlan % for the flexible design dam
        flexexp(i) = infra_cost(3) + infra_cost(4+i); %flexexp(i) = infra_cost(4) + infra_cost(4+i); % total expanded cost for each option
    end
    for i=length(flexexp)-optParam.numPlan+1:length(flexexp) % for the flexiblity planned dam
        flexexp(i) = infra_cost(4) + infra_cost(4+optParam.numFlex+i); %flexexp(i) = infra_cost(4) + infra_cost(4+i); % total expanded cost for each option
    end
else
    
    % Planning scenario C: dam exists, make decision about new desalination plant
    % 6/16: Not updated
    % desal capital costs
    [infra_cost(2),~,opex_cost] = capacity2desalcost(runParam.desalCapacity(1),0); % small
    infra_cost(3) = capacity2desalcost(runParam.desalCapacity(2),0); % large
    [infra_cost(4), infra_cost(5)] = capacity2desalcost(runParam.desalCapacity(1), runParam.desalCapacity(2));  
    
    % desal capital costs two individual plants
    infra_cost(4) = infra_cost(2);
    infra_cost(5) = capacity2desalcost(runParam.desalCapacity(2) - runParam.desalCapacity(1),0);
end


  
%% Calculate climate transition matrix 

% Calculate the Bellman transition vector for the climate states using the
% Bayesian statistical model

if runParam.calcTmat
    load('BMA_results_RCP85_2020-11-14.mat')
    [T_Temp, T_Precip, ~, ~, ~, ~] = bma2TransMat( NUT, NUP, s_T, s_P, N, climParam);
    T_name = strcat('T_Temp_Precip_', runParam.setPathway) % save a different transition matrix file for different emissions pathways
    save(T_name, 'T_Temp', 'T_Precip')
else
    load('T_Temp_Precip_RCP85B', 'T_Precip') % updated from Jenny
    T_Temp = deterministicTempMatrix(N);
end

% Prune state space REPLACE_WITH_DASH_DASH no need to calculate policies for T and P states
% that are never reached when simulating future climates based on Bayesian
% model
for t = 1:N
    index_s_p_time{t} = find(~isnan(T_Precip(1,:,t)));
    index_s_t_time{t} = find(~isnan(T_Temp(1,:,t)));
end


%% T, P, Runoff monthly time series for each long-term T, P state

% Use k-nn stochastic weather generator (Rajagopalan et al. 1999) to
% generate time series of monthly T and P based on 20-year means from state
% space

if runParam.runTPts

    T_ts = cell(M_T_abs,N);
    P_ts = cell(M_P_abs,N);

    [Tanom, Panom] = mean2TPtimeseriesMJL_2(1, runParam.steplen, climParam.numSampTS); 
    for t = 1:N

        for i = 1:M_T_abs  
            T_ts{i,t} = Tanom + s_T_abs(i)*ones(size(Tanom));
        end

        for i = 1:M_P_abs  
            Ptmp = Panom + s_P_abs(i)*ones(size(Tanom));
            Ptmp(Ptmp<0) = 0;
            P_ts{i,t} = Ptmp;
        end

    end

    savename_runoff = strcat('runoff_by_state_', jobid,'_', datetime);
    save(savename_runoff, 'T_ts', 'P_ts')

end


% Use CLIRUN hydrological model to simulate runoff monthly time series for
% each T,P time series

if runParam.runRunoff 

    % Generate runoff timeseries - different set for each T,P combination
    runoff = cell(M_T_abs, M_P_abs, N);


    % Set up parallel for running on cluster with SLURM queueing system
    pc = parcluster('local');
    if ~isempty(getenv('SLURM_JOB_ID'))
        parpool(pc, str2num(getenv('SLURM_CPUS_ON_NODE')));
    end

    for t = 1

        % loop over available temp states
        index_s_t_thisPeriod = index_s_t_time{t}; 
        parfor i = 1:length(index_s_t_thisPeriod)
            index_s_t = index_s_t_thisPeriod(i);

            runoff_temp = cell(M_P_abs,1);

            % loop over available precip states
            index_s_p_thisPeriod = index_s_p_time{t}; 
            for index_s_p = index_s_p_thisPeriod

                % Call CLIRUN streamflow simulator
                runoff_temp{index_s_p} = ...
                    TP2runoff(T_ts{index_s_t,t}, P_ts{index_s_p,t}, runParam.steplen);

            end

            runoff(i, :, t) = runoff_temp;

        end
    end


    savename_runoff = strcat('runoff_by_state_', jobid,'_', datetime);
    save(savename_runoff, 'runoff', 'T_ts', 'P_ts')


    if runParam.runoffPostProcess
        % The nature of the parfor loop above saves the runoff timeseries in
        % first available index; this section moves to correct cell
        % corresponsing to P, T state space
        runoff_post = cell(M_T_abs, M_P_abs, N);
        for t = 1:N

            index_s_p_thisPeriod = index_s_p_time{t}; 
            for index_s_p = index_s_p_thisPeriod

                index_s_t_thisPeriod = index_s_t_time{t}; 
                for i= 1:length(index_s_t_thisPeriod)

                    runoff_post{index_s_t_thisPeriod(i),index_s_p,t} = runoff{i,index_s_p,t};

                end
            end
        end

        runoff = runoff_post;

        savename_runoff = strcat('runoff_by_state_', jobid,'_', datetime);
        save(savename_runoff, 'runoff', 'T_ts', 'P_ts')

    end

else

% If not calculating runoff now, load previously calculated runoff 
load(runParam.runoffLoadName);

end

%% Use reservoir operation model to calculate yield and shortage costs

if runParam.calcShortage

    unmet_ag = nan(M_T_abs, M_P_abs, length(storage), N);   % Unmet demand for agriculture use
    unmet_dom = nan(M_T_abs, M_P_abs, length(storage), N);  % Unmet demand for domestic use
    unmet_ag_squared = nan(M_T_abs, M_P_abs, length(storage), N); % Squared unmet agriculuture demands
    unmet_dom_squared = nan(M_T_abs, M_P_abs, length(storage), N); % Squared unmet domestic demands
    yield = nan(M_T_abs, M_P_abs, length(storage), N);  % Yield from reservoir
    desal = cell(M_T_abs, M_P_abs, length(storage));    % Production of desalinated water

    for t = 1 % Consider N = 1 assuming that the hydrological model and reservoir operations do not vary significantly between planning periods (N)
        
        index_s_p_thisPeriod = index_s_p_time{t}; 
        
        for index_s_p = 1:length(s_P_abs)

            index_s_t_thisPeriod = index_s_t_time{t}; 
            for index_s_t= 1:length(s_T_abs)

                for s = 1:length(storage) % for each capacity scenario, find shortage costs from operations
                    % Two options depending on planning scenario from Table
                    % 1: In scenarios A and B, with low demand, only the
                    % dam is modeled, and different levels of capacity in
                    % the state space corresponds to different reservoir
                    % volumes (desalOn = false). In scenario C, a
                    % desalination plant is modeled to support higher
                    % demand > MAR. In this case (desalOn = true), the
                    % state space corresponds to different desalination
                    % capacity volumes, assuming the large volume of
                    % reservoir storage.
                    
                    if ~runParam.desalOn
                        % vary storage, no desal
                        [yield_mdl, K, dmd, unmet_dom_mdl, unmet_ag_mdl, desalsupply, desalfill]  = ...
                            runoff2yield(runoff{index_s_t,index_s_p,t}, T_ts{index_s_t,t}, P_ts{index_s_p,t}, storage(s), 0, runParam, climParam, costParam);
                    else
                        % large storage, vary desal
                        [yield_mdl, K, dmd, unmet_dom_mdl, unmet_ag_mdl, desalsupply, desalfill]  = ...
                            runoff2yield(runoff{index_s_t,index_s_p,t}, T_ts{index_s_t,t}, P_ts{index_s_p,t}, storage(2), runParam.desalCapacity(s), runParam, climParam, costParam);
                    end
                    
                    % OMITTED: 'Calculate ummet demand, allowing for 10% of domestic demand
                    % to be unpenalized per 90% reliability goal(unmet_dom_90)'

                    unmet_ag(index_s_t, index_s_p, s, t) = mean(sum(unmet_ag_mdl,2));
                    unmet_dom(index_s_t, index_s_p, s, t) = mean(sum(unmet_dom_mdl,2));
                    unmet_ag_squared(index_s_t, index_s_p, s, t) = mean(sum(unmet_ag_mdl.^2,2)); 
                    unmet_dom_squared(index_s_t, index_s_p, s, t) = mean(sum(unmet_dom_mdl.^2,2)); 
                    yield(index_s_t, index_s_p, s, t) = mean(sum(yield_mdl,2));
                    if runParam.desalOn
                        desal{index_s_t, index_s_p, s} = desalsupply + desalfill;
                    end
                    
                end
                
                stateMsg = strcat('s_p =', num2str(index_s_p), '/ ', num2str(length(s_P_abs)), ', s_t=', num2str(index_s_t), '/  ',  num2str(length(s_T_abs)));
                disp(stateMsg)

            end
        end
    end
    
    % Calculate shortage costs incurred for unmet demand, using
    % differentiated costs for agriculture and domestic shortages and
    % quadratic formulation
    shortageCost =  (unmet_ag_squared * costParam.agShortage + unmet_dom_squared * costParam.domShortage) * 1E6; 
    
    % In planning scenario C with the desalination place, also calculate
    % discounted cost of oeprating the desalination plant
    if runParam.desalOn

        desal_opex = nan(M_T_abs, M_P_abs, length(storage), N);
        for t = 1:N
            discountfactor =  repmat((1+costParam.discountrate) .^ ((t-1)*runParam.steplen+1:1/12:t*runParam.steplen+11/12), 100, 1);
            desal_opex(:,:,:,t) = cell2mat(cellfun(@(x) mean(sum(opex_cost * x ./ discountfactor, 2)), desal, 'UniformOutput', false));
        end
        else
            desal_opex = [];
    end
    
    if runParam.saveOn
        savename_shortageCost = strcat('shortage_costs', jobid,'_', datetime);
        save(savename_shortageCost, 'shortageCost', 'yield', 'unmet_ag', 'unmet_dom', 'unmet_ag_squared', 'unmet_dom_squared','desal_opex')
    end
else % use the pre-calculated shortage cost files to fast-track calculations
    
    % Preallocate final shortage cost matrix
    shortageCost = NaN(M_T_abs, M_P_abs, length(storage), N);
    if runParam.optReservoir % shortage costs from adaptive reservoir operations via SDP
        for i=1:length(storage)
            s_state = string(storage(i));
            s_state_filename = strcat('sdp_adaptive_shortage_cost_s',s_state,'.mat');
            shortageCostDir = load(s_state_filename,'shortageCost');
            shortageCost_s_state = shortageCostDir.shortageCost(:,18:49);
            shortageCost(:,:,i,1) = shortageCost_s_state;
        end
    else % shortage costs from non-adaptive reservoir operations via SDP
        for i=1:length(storage)
            s_state = string(storage(i));
            s_state_filename = strcat('sdp_nonadaptive_shortage_cost_s',s_state,'.mat');
            shortageCostDir = load(s_state_filename,'shortageCost');
            shortageCost_s_state = shortageCostDir.shortageCost(:,18:49);
            shortageCost(:,:,i,1) = shortageCost_s_state;
        end
    end
end

%% Solve SDP optimal policies using backwards recursion

if runParam.runSDP

% multiply by c' parameter for economic cost model
shortageCost = shortageCost.*costParam.cPrime;

% Initialize best value and best action matrices
% Temperature states x precipitaiton states x capacity states, time
V = NaN(M_T_abs, M_P_abs, M_C, N+1);
X = NaN(M_T_abs, M_P_abs, M_C, N);

% Terminal period
V(:,:,:,N+1) = zeros(M_T_abs, M_P_abs, M_C, 1);

% Loop over all time periods
for t = linspace(N,1,N)
    
    % Calculate nextV    
    nextV = V(:,:,:,t+1);
          
    % Loop over all states
    
    % Loop over temperature state
    index_s_t_thisPeriod = index_s_t_time{t}; 
    for index_s_t = index_s_t_thisPeriod
        st = s_T_abs(index_s_t);
        
        % Loop over precipitation state
        index_s_p_thisPeriod = index_s_p_time{t}; 
        for index_s_p = index_s_p_thisPeriod
            sp = s_P_abs(index_s_p);
       
            % Loop over capacity expansion state
            for index_s_c = 1:M_C
                sc = s_C(index_s_c);

                bestV = Inf;  % Best value
                bestX = 0;  % Best action

                % Update available actions based on time and whether expansion available
                
                % In first period decide what dam to build
                if t == 1
                    if optParam.optFlex == 1 % flexible dam design
                        a_exp_thisPeriod = 2; % force building of flexible dam design at N = 1
                    elseif optParam.optFlex == 2 % static dam
                        a_exp_thisPeriod = 1; % force building of static dam at N = 1
                    elseif optParam.optFlex == 3 % flexibly planned dam
                        a_exp_thisPeriod = 1; % force building flexibly planned dam at N = 1
                    elseif optParam.optFlex == 0 % flexible design, planning, or static (whatever is best option)
                        a_exp_thisPeriod = 1:3; % build a static or flex dam
                    end
                else
                    % In later periods decide whether to expand or not if available
                    switch sc
                        case s_C(1) % static 
                            a_exp_thisPeriod = [0];
                        case s_C(2) % Flex design, not expanded
                            a_exp_thisPeriod = [0 a_exp(5:5+optParam.numFlex)]; % not expand or expand to options X
                        case s_C(3) % Flex planning, not expanded
                            a_exp_thisPeriod = [0 a_exp(6+optParam.numFlex:end)]; % not expand or expand to option X
                        otherwise % Flex design or planning, any expanded option (can only expand once)
                            a_exp_thisPeriod = [0];
                    end
                end
                num_a_exp = length(a_exp_thisPeriod);

                % Loop over expansion action
                for index_a = 1:num_a_exp
                    a = a_exp_thisPeriod(index_a);
                    
                    stateMsg = strcat('t=', num2str(t), ', st=', num2str(st), ', sp=', num2str(sp), ', sc=', num2str(sc), ', a=', num2str(a));
                    disp(stateMsg)

                    % Calculate costs 
                    
                    % Select which capacity is currently available
                    if sc == 1 
                        short_ind = 1;  % static capacity  
                    elseif sc == 2 
                        short_ind = 2; % flex design capacity
                    elseif sc == 3
                        short_ind = 3; % flex planning capacity
                    else
                        short_ind = sc; % intermediate capacity X
                    end

                    % In first time period, assume have dam built
                    if t == 1
                        if a == 2
                            short_ind = 2; % unexpanded flex design capacity
                        elseif a == 1 
                            short_ind = 1; % static capacity
                        elseif a == 3
                            short_ind = 3; % unexpanded flex planning capacity
                        end
                    end
                    
                    % Assume new expansion capacity comes online this period
                    if (a ~= 0) && (a ~=1) && (a ~=2) && (a ~=3)
                        short_ind = a; % expanded capacity index
                    end
                    
                    sCost = shortageCost(index_s_t, index_s_p, short_ind, 1);
                    if t == 1 
                        sCost = 0;  % This is upfront building period
                    end
                  
                    ind_dam = find(a == a_exp);
                    dCost = infra_cost(ind_dam);
                    cost = (sCost + dCost) / (1+costParam.discountrate)^((t-1)*runParam.steplen+1);
                    if runParam.desalOn
                        opex = desal_opex(index_s_t, index_s_p, short_ind, t);
                    else
                        opex = 0;
                    end
                    cost = cost + opex;
                                      
                   
                    % Calculate transition matrix
                    
                    % Capacity transmat vector
                    T_cap = zeros(1,M_C);
                    if t == 1
                        % In first time period, get whatever dam you picked
                        T_cap(a) = 1;
                    else
                        % Otherwise, either stay in current or move to expanded
                        switch a
                            case 0
                                T_cap(sc) = 1;
                            case num2cell(4:a_exp(end)) % different expansion cases
                                T_cap(a) = 1;
                        end                         
                    end

                    % Temperature transmat vector
                    T_Temp_row = T_Temp(:,index_s_t, t)';
                    if sum(isnan(T_Temp_row)) > 0
                        error('Nan in T_Temp_row')
                    end
                    
                    % Precipitation transmat vector
                    T_Precip_row = T_Precip(:,index_s_p, t)';
                    if sum(isnan(T_Precip_row)) > 0
                        error('Nan in T_Precip_row')
                    end
                    
                    % Calculate full transition matrix
                    % Assumes state variables are uncorrelated
                    % T gives probability of next state given current state and actions

                    TRows = cell(3,1);
                    TRows{1} = T_Temp_row;
                    TRows{2} = T_Precip_row;
                    TRows{3} = T_cap;
                    [ T ] = transrow2mat( TRows );

                     % Calculate expected future cost or percentile cost
                    indexNonZeroT = find(T > 0);
                    expV = sum(T(indexNonZeroT) .*nextV(indexNonZeroT));
                    for i = 2:4
                        expV = sum(expV);
                    end
                    
                   % Check if best decision
                    checkV = cost + expV;
                    if checkV < bestV
                        bestV = checkV;
                        bestX = a;
                    end
                                        
                end
            
            % Check that bestV is not Inf
            if bestV == Inf
                error('BestV is Inf, did not pick an action')
            end

            % Save best value and action for current state
            V(index_s_t, index_s_p,index_s_c, t) = bestV;
            X(index_s_t, index_s_p,index_s_c, t) = bestX;
            
            end
        end
    end
end

if runParam.saveOn
    
    savename_results = strcat('results', jobid,'_', datetime);
    save(savename_results)
    
end


end

%% Forward simulation

% Use optimal expansion policy derived from SDP to simulate performance of
% flexible alternative and compare to small and large alternatives

% 2 runs: static, flex

if runParam.forwardSim
        
R = 10000; % Number of forward Monte Carlo simulations
N = runParam.N; % Number of time periods
S = 4; % Number of run options (static, flex design, flex plan, policy)

T_state = zeros(R,N);
P_state = zeros(R,N);
C_state = zeros(R,N,S);
action = zeros(R,N,S);
damCostTime = zeros(R,N,S);
shortageCostTime = zeros(R,N,S);
opexCostTime = zeros(R,N,S);
totalCostTime = zeros(R,N,S); 

load('BMA_results_RCP85_2020-11-14.mat', 'MUP') % previously: 'BMA_results_deltap05T_p2P07-Feb-2018 20:18:49.mat'
indT0 = find(s_T_abs == climParam.T0_abs);
indP0 = find(s_P_abs == climParam.P0_abs);
P0samp = MUP(:,1,indP0);
P0samp = exp(P0samp)* climParam.P0_abs;
indsamp = randi(1000,R,1);
P0samp = P0samp(indsamp);
T0samp = round2x(s_T_abs(1), s_T_abs);
P0samp = round2x(P0samp, s_P_abs);

T_state(:,1) = T0samp;
P_state(:,1) = P0samp;
C_state(:,1,1) = 2; % Always flex design
C_state(:,1,2) = 1; % Always static
C_state(:,1,3) = 3; % Always flex planned
C_state(:,1,4) = 2; % Choose based on policy (?)

for i = 1:R
    for t = 1:N
        
        % Choose best action given current state
            index_t = find(T_state(i,t) == s_T_abs);
            index_p = find(P_state(i,t) == s_P_abs);
            
        
        % Temperature transmat vector
            T_Temp_row = T_Temp(:,index_t, t)';
            if sum(isnan(T_Temp_row)) > 0
                error('Nan in T_Temp_row')
            end

            % Precipitation transmat vector
            T_Precip_row = T_Precip(:,index_p, t)';
            if sum(isnan(T_Precip_row)) > 0
                error('Nan in T_Precip_row')
            end
        
        for k = 1:4
            
            index_c = find(C_state(i,t,k) == s_C); % (?)
            % In flex case follow exp policy, otherwise restrict to large or
            % small and then no exp
            if t==1
                switch k
                    case 1
                        action(i,t,k) = 2; % flex design 
                    case 2
                        action(i,t,k) = 1; % static
                    case 3
                        action(i,t,k) = 3; % flex planning
                    case 4
                        action(i,t,k) =  X(index_t, index_p, index_c, t); % pick best option
                end
            else 
                switch k
                    case 1
                        action(i,t,k) = X(index_t, index_p, index_c, t); % flex design
                    case 2
                        action(i,t,k) = 0; % static
                    case 3 
                        action(i,t,k) =  X(index_t, index_p, index_c, t); %flex planning
                    case 4
                        action(i,t,k) =  X(index_t, index_p, index_c, t); % pick best option
                end
            end
            
            % Save costs of that action

            % Get current capacity and action
            sc = C_state(i,t,k); %for the first time period, either 1,2, or 3
            a = action(i,t,k);

            % Select which capacity is currently available
            if sc == 1 
                short_ind = 1;  % static capacity  
            elseif sc == 2 
                short_ind = 2; % flex design capacity
            elseif sc == 3
                short_ind = 3; % flex planning capacity
            else
                short_ind = sc; % intermediate expanded capacity           
            end

            % In first time period, assume have dam built
            if t == 1
                if a == 2
                    short_ind = 2; % flex design capacity 
                elseif a == 1 
                    short_ind = 1;    % static capacity
                else
                    short_ind = 3; % flex planning capacity 
                end
            end
            
            % Assume new expansion capacity comes online this period
            if (a ~= 0) && (a ~=1) && (a ~=2) && (a~=3)
                short_ind = a; % expanded capacity index
            end

            % Get shortage and dam costs
            shortageCostTime(i,t,k) = shortageCost(index_t, index_p, short_ind, 1)  / (1+costParam.discountrate)^((t-1)*runParam.steplen+1);
            if t == 1 
                shortageCostTime(i,t,k) = 0;  % This is upfront building period
            end
            ind_dam = find(a == a_exp);
            damCostTime(i,t,k) = infra_cost(ind_dam)  / (1+costParam.discountrate)^((t-1)*runParam.steplen+1);
            if runParam.desalOn
                opexCostTime(i,t,k) = desal_opex(index_t, index_p, short_ind, t);
            end
            totalCostTime(i,t,k) = (shortageCostTime(i,t,k) + damCostTime(i,t,k));
            totalCostTime(i,t,k) = totalCostTime(i,t,k) + opexCostTime(i,t,k);
            
            % Simulate transition to next state
            % Capacity transmat vector
            T_cap = zeros(1,M_C);
            if t == 1
                % In first time period, get whatever dam you picked
                T_cap(a) = 1;
            else
                % Otherwise, either stay in current or move to expanded
                switch a %(?)
                    case 0
                        T_cap(sc) = 1;
                    case num2cell(4:a_exp(end)) % different expansion cases
                        T_cap(a) = 1;
                end
            end

            
            % Combine trans vectors into matrix
            TRows = cell(3,1);
            TRows{1} = T_Temp_row;
            TRows{2} = T_Precip_row;
            TRows{3} = T_cap;
            [ T_current ] = transrow2mat( TRows );

            % Simulate next state
            if t < N
                T_current_1D = reshape(T_current,[1 numel(T_current)]);
                T_current_1D_cumsum = cumsum(T_current_1D);
                p = rand();
                index = find(p < T_current_1D_cumsum,1);
                [ind_s1, ind_s2, ind_s3] = ind2sub(size(T_current),index);
                    % Test sample
                    margin = 1e-10;
                    if (T_current(ind_s1, ind_s2, ind_s3) < margin)
                        error('Invalid sample from T_current')
                    end
                
                if k == 1
                    T_state(i,t+1,k) = s_T_abs(ind_s1);
                    P_state(i,t+1,k) = s_P_abs(ind_s2);
                end
                C_state(i,t+1,k) = s_C(ind_s3);

            end



        end

    end
end


if runParam.saveOn
    
    savename_results = strcat('results', jobid,'_', datetime);
    save(savename_results)
    
end


end

##### SOURCE END #####
--></body></html>